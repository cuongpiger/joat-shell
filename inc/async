#!/bin/bash

####################################################################################################
# Author: Cuong. Duong Manh <cuongdm8499@gmail.com>
# Description: This script is used to run a function in background.
####################################################################################################

# ***************************************** PUBLIC METHODS *****************************************

# Make sure our async dir is created and clean
function async_init {
  local async_dir=${JOAT_SHELL_DEST}/async

  # Clean any residue if present from previous runs
  rm -Rf $async_dir

  # Make sure we have a state directory
  mkdir -p $async_dir
}

# Shortcut for running a shell function async. Uses the function name as the async name
function async_runfunc {
  async_run $1 $*
}

# Check for uncollected futures and wait on them
function async_cleanup {
  local name

  if [[ "$ALLOWING_PARALLEL" != "True" ]]; then
    return 0
  fi

  for inifile in $(find ${JOAT_SHELL_DEST}/async -name '*.ini'); do
    name=$(basename $pidfile .ini)
    echo "WARNING: uncollected async future $name"
    async_wait $name || true
  done
}

# **************************************** PRIVATE METHODS *****************************************

# Run something async. Takes a symbolic name and a list of arguments of what to run. Ideally this
# would be rarely used and async_runfunc() would be used everywhere for readability.
#
# This spawns the work in a background worker, records a "future" to be collected by a later call
# to async_wait()
function async_run {
  local xtrace
  xtrace=$(set +o | grep xtrace)
  set +o xtrace

  local name="$1"
  shift
  local inifile=${JOAT_SHELL_DEST}/async/${name}.ini
  local fifo=${JOAT_SHELL_DEST}/async/${name}.fifo

  touch $inifile
  iniset $inifile job command "$*"
  iniset $inifile job start_time $(date +%s%3N)

  if [[ "$ALLOWING_PARALLEL" = "True" ]]; then
    mkfifo $fifo # Create a FIFO file
    async_inner $name $* &
    iniset $inifile job pid $!
    async_log "$name" "running: %command"
    $xtrace
  else
    iniset $inifile job pid "self"
    async_log "$name" "Running synchronously: %command"
    $xtrace
    $*
    return $?
  fi
}

# Inner function that actually runs the requested task. I wrap it like this just so I can emit a
# finish message as soon as the work is done, to make it easier to find the tracking just before an
# error.
function async_inner {
  local name="$1"
  local rc
  local fifo="${JOAT_SHELL_DEST}/async/${name}.fifo"
  shift
  set -o xtrace
  if $* >${JOAT_SHELL_DEST}/async/${name}.log 2>&1; then
    rc=0
    set +o xtrace
    async_log "$name" "finished successfully"
  else
    rc=$?
    set +o xtrace
    async_log "$name" "FAILED with rc $rc"
  fi
  iniset ${JOAT_SHELL_DEST}/async/${name}.ini job end_time $(date "+%s%3N")
  # Block on the fifo until we are signaled to exit by the main process
  cat $fifo
  return $rc
}

# Log a message about a job. If the message contains "%command" then the full command line of the
# job will be substituted in the output
function async_log {
  local name="$1"
  shift
  local message="$*"
  local inifile=${JOAT_SHELL_DEST}/async/${name}.ini
  local pid
  local command

  pid=$(iniget $inifile job pid)
  command=$(iniget $inifile job command | tr '#' '-')
  message=$(echo "$message" | sed "s#%command#$command#g")

  echo "[$BASHPID Async ${name}:${pid}]: $message"
}
